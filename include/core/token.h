/**
 * Nescc
 * Copyright (C) 2017-2018 David Jolly
 *
 * Nescc is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Nescc is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef NESCC_CORE_TOKEN_H_
#define NESCC_CORE_TOKEN_H_

#include <map>
#include "./unique_id.h"

namespace nescc {

	namespace core {

		enum {
			COMMAND_ADC = 0,
			COMMAND_AND,
			COMMAND_ASL,
			COMMAND_BCC,
			COMMAND_BCS,
			COMMAND_BEQ,
			COMMAND_BIT,
			COMMAND_BMI,
			COMMAND_BNE,
			COMMAND_BPL,
			COMMAND_BRK,
			COMMAND_BVC,
			COMMAND_BVS,
			COMMAND_CLC,
			COMMAND_CLD,
			COMMAND_CLI,
			COMMAND_CLV,
			COMMAND_CMP,
			COMMAND_CPX,
			COMMAND_CPY,
			COMMAND_DEC,
			COMMAND_DEX,
			COMMAND_DEY,
			COMMAND_EOR,
			COMMAND_ILLEGAL_AHX,
			COMMAND_ILLEGAL_ALR,
			COMMAND_ILLEGAL_ANC,
			COMMAND_ILLEGAL_ARR,
			COMMAND_ILLEGAL_AXS,
			COMMAND_ILLEGAL_DCP,
			COMMAND_ILLEGAL_ISC,
			COMMAND_ILLEGAL_KIL,
			COMMAND_ILLEGAL_LAS,
			COMMAND_ILLEGAL_LAX,
			COMMAND_ILLEGAL_NOP,
			COMMAND_ILLEGAL_RLA,
			COMMAND_ILLEGAL_RRA,
			COMMAND_ILLEGAL_SAX,
			COMMAND_ILLEGAL_SBC,
			COMMAND_ILLEGAL_SHX,
			COMMAND_ILLEGAL_SHY,
			COMMAND_ILLEGAL_SLO,
			COMMAND_ILLEGAL_SRE,
			COMMAND_ILLEGAL_TAS,
			COMMAND_ILLEGAL_XAA,
			COMMAND_INC,
			COMMAND_INX,
			COMMAND_INY,
			COMMAND_JMP,
			COMMAND_JSR,
			COMMAND_LDA,
			COMMAND_LDX,
			COMMAND_LDY,
			COMMAND_LSR,
			COMMAND_NOP,
			COMMAND_ORA,
			COMMAND_PHA,
			COMMAND_PHP,
			COMMAND_PLA,
			COMMAND_PLP,
			COMMAND_ROL,
			COMMAND_ROR,
			COMMAND_RTI,
			COMMAND_RTS,
			COMMAND_SBC,
			COMMAND_SEC,
			COMMAND_SED,
			COMMAND_SEI,
			COMMAND_STA,
			COMMAND_STX,
			COMMAND_STY,
			COMMAND_TAX,
			COMMAND_TAY,
			COMMAND_TSX,
			COMMAND_TXA,
			COMMAND_TXS,
			COMMAND_TYA,
		};

		#define COMMAND_MAX COMMAND_TYA

		static const std::string COMMAND_STR[] = {
			"adc", "and", "asl", "bcc", "bcs", "beq", "bit", "bmi", "bne", "bpl",
			"brk", "bvc", "bvs", "clc", "cld", "cli", "clv", "cmp", "cpx", "cpy",
			"dec", "dex", "dey", "eor", "?ahx", "?alr", "?anc", "?arr", "?axs", "?dcp",
			"?isc", "?kil", "?las", "?lax", "?nop", "?rla", "?rra", "?sax", "?sbc", "?shx",
			"?shy", "?slo", "?sre", "?tas", "?xaa", "inc", "inx", "iny", "jmp", "jsr",
			"lda", "ldx", "ldy", "lsr", "nop", "ora", "pha", "php", "pla", "plp",
			"rol", "ror", "rti", "rts", "sbc", "sec", "sed", "sei", "sta", "stx",
			"sty", "tax", "tay", "tsx", "txa", "txs", "tya",
			};

		#define COMMAND_STRING(_TYPE_) \
			(((_TYPE_) > nescc::core::COMMAND_MAX) ? STRING_UNKNOWN : \
				STRING_CHECK(nescc::core::COMMAND_STR[_TYPE_]))

		static const std::map<std::string, int> COMMAND_MAP = {
			std::make_pair(COMMAND_STR[COMMAND_ADC], COMMAND_ADC), // COMMAND_ADC
			std::make_pair(COMMAND_STR[COMMAND_AND], COMMAND_AND), // COMMAND_AND
			std::make_pair(COMMAND_STR[COMMAND_ASL], COMMAND_ASL), // COMMAND_ASL
			std::make_pair(COMMAND_STR[COMMAND_BCC], COMMAND_BCC), // COMMAND_BCC
			std::make_pair(COMMAND_STR[COMMAND_BCS], COMMAND_BCS), // COMMAND_BCS
			std::make_pair(COMMAND_STR[COMMAND_BEQ], COMMAND_BEQ), // COMMAND_BEQ
			std::make_pair(COMMAND_STR[COMMAND_BIT], COMMAND_BIT), // COMMAND_BIT
			std::make_pair(COMMAND_STR[COMMAND_BMI], COMMAND_BMI), // COMMAND_BMI
			std::make_pair(COMMAND_STR[COMMAND_BNE], COMMAND_BNE), // COMMAND_BNE
			std::make_pair(COMMAND_STR[COMMAND_BPL], COMMAND_BPL), // COMMAND_BPL
			std::make_pair(COMMAND_STR[COMMAND_BRK], COMMAND_BRK), // COMMAND_BRK
			std::make_pair(COMMAND_STR[COMMAND_BVC], COMMAND_BVC), // COMMAND_BVC
			std::make_pair(COMMAND_STR[COMMAND_BVS], COMMAND_BVS), // COMMAND_BVS
			std::make_pair(COMMAND_STR[COMMAND_CLC], COMMAND_CLC), // COMMAND_CLC
			std::make_pair(COMMAND_STR[COMMAND_CLD], COMMAND_CLD), // COMMAND_CLD
			std::make_pair(COMMAND_STR[COMMAND_CLI], COMMAND_CLI), // COMMAND_CLI
			std::make_pair(COMMAND_STR[COMMAND_CLV], COMMAND_CLV), // COMMAND_CLV
			std::make_pair(COMMAND_STR[COMMAND_CMP], COMMAND_CMP), // COMMAND_CMP
			std::make_pair(COMMAND_STR[COMMAND_CPX], COMMAND_CPX), // COMMAND_CPX
			std::make_pair(COMMAND_STR[COMMAND_CPY], COMMAND_CPY), // COMMAND_CPY
			std::make_pair(COMMAND_STR[COMMAND_DEC], COMMAND_DEC), // COMMAND_DEC
			std::make_pair(COMMAND_STR[COMMAND_DEX], COMMAND_DEX), // COMMAND_DEX
			std::make_pair(COMMAND_STR[COMMAND_DEY], COMMAND_DEY), // COMMAND_DEY
			std::make_pair(COMMAND_STR[COMMAND_EOR], COMMAND_EOR), // COMMAND_EOR
			std::make_pair(COMMAND_STR[COMMAND_ILLEGAL_AHX], COMMAND_ILLEGAL_AHX), // COMMAND_ILLEGAL_AHX
			std::make_pair(COMMAND_STR[COMMAND_ILLEGAL_ALR], COMMAND_ILLEGAL_ALR), // COMMAND_ILLEGAL_ALR
			std::make_pair(COMMAND_STR[COMMAND_ILLEGAL_ANC], COMMAND_ILLEGAL_ANC), // COMMAND_ILLEGAL_ANC
			std::make_pair(COMMAND_STR[COMMAND_ILLEGAL_ARR], COMMAND_ILLEGAL_ARR), // COMMAND_ILLEGAL_ARR
			std::make_pair(COMMAND_STR[COMMAND_ILLEGAL_AXS], COMMAND_ILLEGAL_AXS), // COMMAND_ILLEGAL_AXS
			std::make_pair(COMMAND_STR[COMMAND_ILLEGAL_DCP], COMMAND_ILLEGAL_DCP), // COMMAND_ILLEGAL_DCP
			std::make_pair(COMMAND_STR[COMMAND_ILLEGAL_ISC], COMMAND_ILLEGAL_ISC), // COMMAND_ILLEGAL_ISC
			std::make_pair(COMMAND_STR[COMMAND_ILLEGAL_KIL], COMMAND_ILLEGAL_KIL), // COMMAND_ILLEGAL_KIL
			std::make_pair(COMMAND_STR[COMMAND_ILLEGAL_LAS], COMMAND_ILLEGAL_LAS), // COMMAND_ILLEGAL_LAS
			std::make_pair(COMMAND_STR[COMMAND_ILLEGAL_LAX], COMMAND_ILLEGAL_LAX), // COMMAND_ILLEGAL_LAX
			std::make_pair(COMMAND_STR[COMMAND_ILLEGAL_NOP], COMMAND_ILLEGAL_NOP), // COMMAND_ILLEGAL_NOP
			std::make_pair(COMMAND_STR[COMMAND_ILLEGAL_RLA], COMMAND_ILLEGAL_RLA), // COMMAND_ILLEGAL_RLA
			std::make_pair(COMMAND_STR[COMMAND_ILLEGAL_RRA], COMMAND_ILLEGAL_RRA), // COMMAND_ILLEGAL_RRA
			std::make_pair(COMMAND_STR[COMMAND_ILLEGAL_SAX], COMMAND_ILLEGAL_SAX), // COMMAND_ILLEGAL_SAX
			std::make_pair(COMMAND_STR[COMMAND_ILLEGAL_SBC], COMMAND_ILLEGAL_SBC), // COMMAND_ILLEGAL_SBC
			std::make_pair(COMMAND_STR[COMMAND_ILLEGAL_SHX], COMMAND_ILLEGAL_SHX), // COMMAND_ILLEGAL_SHX
			std::make_pair(COMMAND_STR[COMMAND_ILLEGAL_SHY], COMMAND_ILLEGAL_SHY), // COMMAND_ILLEGAL_SHY
			std::make_pair(COMMAND_STR[COMMAND_ILLEGAL_SLO], COMMAND_ILLEGAL_SLO), // COMMAND_ILLEGAL_SLO
			std::make_pair(COMMAND_STR[COMMAND_ILLEGAL_SRE], COMMAND_ILLEGAL_SRE), // COMMAND_ILLEGAL_SRE
			std::make_pair(COMMAND_STR[COMMAND_ILLEGAL_TAS], COMMAND_ILLEGAL_TAS), // COMMAND_ILLEGAL_TAS
			std::make_pair(COMMAND_STR[COMMAND_ILLEGAL_XAA], COMMAND_ILLEGAL_XAA), // COMMAND_ILLEGAL_XAA
			std::make_pair(COMMAND_STR[COMMAND_INC], COMMAND_INC), // COMMAND_INC
			std::make_pair(COMMAND_STR[COMMAND_INX], COMMAND_INX), // COMMAND_INX
			std::make_pair(COMMAND_STR[COMMAND_INY], COMMAND_INY), // COMMAND_INY
			std::make_pair(COMMAND_STR[COMMAND_JMP], COMMAND_JMP), // COMMAND_JMP
			std::make_pair(COMMAND_STR[COMMAND_JSR], COMMAND_JSR), // COMMAND_JSR
			std::make_pair(COMMAND_STR[COMMAND_LDA], COMMAND_LDA), // COMMAND_LDA
			std::make_pair(COMMAND_STR[COMMAND_LDX], COMMAND_LDX), // COMMAND_LDX
			std::make_pair(COMMAND_STR[COMMAND_LDY], COMMAND_LDY), // COMMAND_LDY
			std::make_pair(COMMAND_STR[COMMAND_LSR], COMMAND_LSR), // COMMAND_LSR
			std::make_pair(COMMAND_STR[COMMAND_NOP], COMMAND_NOP), // COMMAND_NOP
			std::make_pair(COMMAND_STR[COMMAND_ORA], COMMAND_ORA), // COMMAND_ORA
			std::make_pair(COMMAND_STR[COMMAND_PHA], COMMAND_PHA), // COMMAND_PHA
			std::make_pair(COMMAND_STR[COMMAND_PHP], COMMAND_PHP), // COMMAND_PHP
			std::make_pair(COMMAND_STR[COMMAND_PLA], COMMAND_PLA), // COMMAND_PLA
			std::make_pair(COMMAND_STR[COMMAND_PLP], COMMAND_PLP), // COMMAND_PLP
			std::make_pair(COMMAND_STR[COMMAND_ROL], COMMAND_ROL), // COMMAND_ROL
			std::make_pair(COMMAND_STR[COMMAND_ROR], COMMAND_ROR), // COMMAND_ROR
			std::make_pair(COMMAND_STR[COMMAND_RTI], COMMAND_RTI), // COMMAND_RTI
			std::make_pair(COMMAND_STR[COMMAND_RTS], COMMAND_RTS), // COMMAND_RTS
			std::make_pair(COMMAND_STR[COMMAND_SBC], COMMAND_SBC), // COMMAND_SBC
			std::make_pair(COMMAND_STR[COMMAND_SEC], COMMAND_SEC), // COMMAND_SEC
			std::make_pair(COMMAND_STR[COMMAND_SED], COMMAND_SED), // COMMAND_SED
			std::make_pair(COMMAND_STR[COMMAND_SEI], COMMAND_SEI), // COMMAND_SEI
			std::make_pair(COMMAND_STR[COMMAND_STA], COMMAND_STA), // COMMAND_STA
			std::make_pair(COMMAND_STR[COMMAND_STX], COMMAND_STX), // COMMAND_STX
			std::make_pair(COMMAND_STR[COMMAND_STY], COMMAND_STY), // COMMAND_STY
			std::make_pair(COMMAND_STR[COMMAND_TAX], COMMAND_TAX), // COMMAND_TAX
			std::make_pair(COMMAND_STR[COMMAND_TAY], COMMAND_TAY), // COMMAND_TAY
			std::make_pair(COMMAND_STR[COMMAND_TSX], COMMAND_TSX), // COMMAND_TSX
			std::make_pair(COMMAND_STR[COMMAND_TXA], COMMAND_TXA), // COMMAND_TXA
			std::make_pair(COMMAND_STR[COMMAND_TXS], COMMAND_TXS), // COMMAND_TXS
			std::make_pair(COMMAND_STR[COMMAND_TYA], COMMAND_TYA), // COMMAND_TYA
			};

		enum {
			PRAGMA_COMMAND_DEFINE = 0,
			PRAGMA_COMMAND_INCLUDE,
			PRAGMA_COMMAND_ORIGIN,
			PRAGMA_COMMAND_PAGE_CHARACTER,
			PRAGMA_COMMAND_PAGE_PROGRAM,
			PAAGMA_COMMAND_PAGE_SIZE,
			PRAGMA_COMMAND_UNDEFINE,
			PRAGMA_CONDITION_ELSE,
			PRAGMA_CONDITION_END,
			PRAGMA_CONDITION_IF,
			PRAGMA_CONDITION_IF_DEFINE,
			PRAGMA_DATA_BYTE,
			PRAGMA_DATA_PART_HIGH,
			PRAGMA_DATA_PART_LOW,
			PRAGMA_DATA_RESERVE,
			PRAGMA_DATA_WORD,
			PRAGMA_INES_MAPPER,
			PRAGMA_INES_MIRRORING,
			PRAGMA_INES_ROM_CHARACTER,
			PRAGMA_INES_ROM_PROGRAM,
		};

		#define PRAGMA_MAX PRAGMA_INES_ROM_PROGRAM

		static const std::string PRAGMA_STR[] = {
			"def", "inc", "org", "chr", "prg", "size", "undef", "else", "end",
			"if", "ifdef", "db", "high", "low", "rs", "dw", "inesmap", "inesmir",
			"ineschr", "inesprg",
			};

		#define PRAGMA_STRING(_TYPE_) \
			(((_TYPE_) > nescc::core::PRAGMA_MAX) ? STRING_UNKNOWN : \
				STRING_CHECK(nescc::core::PRAGMA_STR[_TYPE_]))

		static const std::map<std::string, int> PRAGMA_MAP = {
			std::make_pair(PRAGMA_STR[PRAGMA_COMMAND_DEFINE], PRAGMA_COMMAND_DEFINE), // PRAGMA_COMMAND_DEFINE
			std::make_pair(PRAGMA_STR[PRAGMA_COMMAND_INCLUDE], PRAGMA_COMMAND_INCLUDE), // PRAGMA_COMMAND_INCLUDE
			std::make_pair(PRAGMA_STR[PRAGMA_COMMAND_ORIGIN], PRAGMA_COMMAND_ORIGIN), // PRAGMA_COMMAND_ORIGIN
			std::make_pair(PRAGMA_STR[PRAGMA_COMMAND_PAGE_CHARACTER], PRAGMA_COMMAND_PAGE_CHARACTER), // PRAGMA_COMMAND_PAGE_CHARACTER
			std::make_pair(PRAGMA_STR[PRAGMA_COMMAND_PAGE_PROGRAM], PRAGMA_COMMAND_PAGE_PROGRAM), // PRAGMA_COMMAND_PAGE_PROGRAM
			std::make_pair(PRAGMA_STR[PAAGMA_COMMAND_PAGE_SIZE], PAAGMA_COMMAND_PAGE_SIZE), // PAAGMA_COMMAND_PAGE_SIZE
			std::make_pair(PRAGMA_STR[PRAGMA_COMMAND_UNDEFINE], PRAGMA_COMMAND_UNDEFINE), // PRAGMA_COMMAND_UNDEFINE
			std::make_pair(PRAGMA_STR[PRAGMA_CONDITION_ELSE], PRAGMA_CONDITION_ELSE), // PRAGMA_CONDITION_ELSE
			std::make_pair(PRAGMA_STR[PRAGMA_CONDITION_END], PRAGMA_CONDITION_END), // PRAGMA_CONDITION_END
			std::make_pair(PRAGMA_STR[PRAGMA_CONDITION_IF], PRAGMA_CONDITION_IF), // PRAGMA_CONDITION_IF
			std::make_pair(PRAGMA_STR[PRAGMA_CONDITION_IF_DEFINE], PRAGMA_CONDITION_IF_DEFINE), // PRAGMA_CONDITION_IF_DEFINE
			std::make_pair(PRAGMA_STR[PRAGMA_DATA_BYTE], PRAGMA_DATA_BYTE), // PRAGMA_DATA_BYTE
			std::make_pair(PRAGMA_STR[PRAGMA_DATA_PART_HIGH], PRAGMA_DATA_PART_HIGH), // PRAGMA_DATA_PART_HIGH
			std::make_pair(PRAGMA_STR[PRAGMA_DATA_PART_LOW], PRAGMA_DATA_PART_LOW), // PRAGMA_DATA_PART_LOW
			std::make_pair(PRAGMA_STR[PRAGMA_DATA_RESERVE], PRAGMA_DATA_RESERVE), // PRAGMA_DATA_RESERVE
			std::make_pair(PRAGMA_STR[PRAGMA_DATA_WORD], PRAGMA_DATA_WORD), // PRAGMA_DATA_WORD
			std::make_pair(PRAGMA_STR[PRAGMA_INES_MAPPER], PRAGMA_INES_MAPPER), // PRAGMA_INES_MAPPER
			std::make_pair(PRAGMA_STR[PRAGMA_INES_MIRRORING], PRAGMA_INES_MIRRORING), // PRAGMA_INES_MIRRORING
			std::make_pair(PRAGMA_STR[PRAGMA_INES_ROM_CHARACTER], PRAGMA_INES_ROM_CHARACTER), // PRAGMA_INES_ROM_CHARACTER
			std::make_pair(PRAGMA_STR[PRAGMA_INES_ROM_PROGRAM], PRAGMA_INES_ROM_PROGRAM), // PRAGMA_INES_ROM_PROGRAM
			};

		enum {
			REGISTER_ACCUMULATOR = 0,
			REGISTER_INDEX_X,
			REGISTER_INDEX_Y,
		};

		#define REGISTER_MAX REGISTER_INDEX_Y

		static const std::string REGISTER_STR[] = {
			"a", "x", "y"
			};

		#define REGISTER_STRING(_TYPE_) \
			(((_TYPE_) > nescc::core::REGISTER_MAX) ? STRING_UNKNOWN : \
				STRING_CHECK(nescc::core::REGISTER_STR[_TYPE_]))

		static const std::map<std::string, int> REGISTER_MAP = {
			std::make_pair(REGISTER_STR[REGISTER_ACCUMULATOR], REGISTER_ACCUMULATOR), // REGISTER_ACCUMULATOR
			std::make_pair(REGISTER_STR[REGISTER_INDEX_X], REGISTER_INDEX_X), // REGISTER_INDEX_X
			std::make_pair(REGISTER_STR[REGISTER_INDEX_Y], REGISTER_INDEX_Y), // REGISTER_INDEX_Y
			};

		enum {
			SYMBOL_ARITHMETIC_ADD = 0,
			SYMBOL_ARITHMETIC_DIVIDE,
			SYMBOL_ARITHMETIC_MODULUS,
			SYMBOL_ARITHMETIC_MULTIPLY,
			SYMBOL_ARITHMETIC_SUBTRACT,
			SYMBOL_BINARY_AND,
			SYMBOL_BINARY_OR,
			SYMBOL_BINARY_XOR,
			SYMBOL_IMMEDIATE,
			SYMBOL_LOGICAL_SHIFT_LEFT,
			SYMBOL_LOGICAL_SHIFT_RIGHT,
			SYMBOL_OPERATOR_AND,
			SYMBOL_OPERATOR_EQUALS,
			SYMBOL_OPERATOR_GREATER_THAN,
			SYMBOL_OPERATOR_GREATER_THAN_EQUALS,
			SYMBOL_OPERATOR_LESS_THAN,
			SYMBOL_OPERATOR_LESS_THAN_EQUALS,
			SYMBOL_OPERATOR_NOT_EQUALS,
			SYMBOL_OPERATOR_OR,
			SYMBOL_PARENTHESIS_CLOSE,
			SYMBOL_PARENTHESIS_OPEN,
			SYMBOL_SEPERATOR,
			SYMBOL_UNARY_NEGATE,
			SYMBOL_UNARY_NOT,
		};

		#define SYMBOL_MAX SYMBOL_UNARY_NOT

		static const std::string SYMBOL_STR[] = {
			"+", "/", "%", "*", "-", "&", "|", "^", "@", "<<", ">>",
			"&&", "==", ">", ">=", "<", "<=", "!=", "||", ")", "(",
			",", "~", "!",
			};

		#define SYMBOL_STRING(_TYPE_) \
			(((_TYPE_) > nescc::core::SYMBOL_MAX) ? STRING_UNKNOWN : \
				STRING_CHECK(nescc::core::SYMBOL_STR[_TYPE_]))

		static const std::map<std::string, int> SYMBOL_MAP = {
			std::make_pair(SYMBOL_STR[SYMBOL_ARITHMETIC_ADD], SYMBOL_ARITHMETIC_ADD), // SYMBOL_ARITHMETIC_ADD
			std::make_pair(SYMBOL_STR[SYMBOL_ARITHMETIC_DIVIDE], SYMBOL_ARITHMETIC_DIVIDE), // SYMBOL_ARITHMETIC_DIVIDE
			std::make_pair(SYMBOL_STR[SYMBOL_ARITHMETIC_MODULUS], SYMBOL_ARITHMETIC_MODULUS), // SYMBOL_ARITHMETIC_MODULUS
			std::make_pair(SYMBOL_STR[SYMBOL_ARITHMETIC_MULTIPLY], SYMBOL_ARITHMETIC_MULTIPLY), // SYMBOL_ARITHMETIC_MULTIPLY
			std::make_pair(SYMBOL_STR[SYMBOL_ARITHMETIC_SUBTRACT], SYMBOL_ARITHMETIC_SUBTRACT), // SYMBOL_ARITHMETIC_SUBTRACT
			std::make_pair(SYMBOL_STR[SYMBOL_BINARY_AND], SYMBOL_BINARY_AND), // SYMBOL_BINARY_AND
			std::make_pair(SYMBOL_STR[SYMBOL_BINARY_OR], SYMBOL_BINARY_OR), // SYMBOL_BINARY_OR
			std::make_pair(SYMBOL_STR[SYMBOL_BINARY_XOR], SYMBOL_BINARY_XOR), // SYMBOL_BINARY_XOR
			std::make_pair(SYMBOL_STR[SYMBOL_IMMEDIATE], SYMBOL_IMMEDIATE), // SYMBOL_IMMEDIATE
			std::make_pair(SYMBOL_STR[SYMBOL_LOGICAL_SHIFT_LEFT], SYMBOL_LOGICAL_SHIFT_LEFT), // SYMBOL_LOGICAL_SHIFT_LEFT
			std::make_pair(SYMBOL_STR[SYMBOL_LOGICAL_SHIFT_RIGHT], SYMBOL_LOGICAL_SHIFT_RIGHT), // SYMBOL_LOGICAL_SHIFT_RIGHT
			std::make_pair(SYMBOL_STR[SYMBOL_OPERATOR_AND], SYMBOL_OPERATOR_AND), // SYMBOL_OPERATOR_AND
			std::make_pair(SYMBOL_STR[SYMBOL_OPERATOR_EQUALS], SYMBOL_OPERATOR_EQUALS), // SYMBOL_OPERATOR_EQUALS
			std::make_pair(SYMBOL_STR[SYMBOL_OPERATOR_GREATER_THAN], SYMBOL_OPERATOR_GREATER_THAN), // SYMBOL_OPERATOR_GREATER_THAN
			std::make_pair(SYMBOL_STR[SYMBOL_OPERATOR_GREATER_THAN_EQUALS], SYMBOL_OPERATOR_GREATER_THAN_EQUALS),
				// SYMBOL_OPERATOR_GREATER_THAN_EQUALS
			std::make_pair(SYMBOL_STR[SYMBOL_OPERATOR_LESS_THAN], SYMBOL_OPERATOR_LESS_THAN), // SYMBOL_OPERATOR_LESS_THAN
			std::make_pair(SYMBOL_STR[SYMBOL_OPERATOR_LESS_THAN_EQUALS], SYMBOL_OPERATOR_LESS_THAN_EQUALS),
				// SYMBOL_OPERATOR_LESS_THAN_EQUALS
			std::make_pair(SYMBOL_STR[SYMBOL_OPERATOR_NOT_EQUALS], SYMBOL_OPERATOR_NOT_EQUALS), // SYMBOL_OPERATOR_NOT_EQUALS
			std::make_pair(SYMBOL_STR[SYMBOL_OPERATOR_OR], SYMBOL_OPERATOR_OR), // SYMBOL_OPERATOR_OR
			std::make_pair(SYMBOL_STR[SYMBOL_PARENTHESIS_CLOSE], SYMBOL_PARENTHESIS_CLOSE), // SYMBOL_PARENTHESIS_CLOSE
			std::make_pair(SYMBOL_STR[SYMBOL_PARENTHESIS_OPEN], SYMBOL_PARENTHESIS_OPEN), // SYMBOL_PARENTHESIS_OPEN
			std::make_pair(SYMBOL_STR[SYMBOL_SEPERATOR], SYMBOL_SEPERATOR), // SYMBOL_SEPERATOR
			std::make_pair(SYMBOL_STR[SYMBOL_UNARY_NOT], SYMBOL_UNARY_NOT), // SYMBOL_UNARY_NOT
			std::make_pair(SYMBOL_STR[SYMBOL_UNARY_NEGATE], SYMBOL_UNARY_NEGATE), // SYMBOL_UNARY_NEGATE
			};

		#define TOKEN_INVALID ((int) -1)

		enum {
			TOKEN_BEGIN = 0,
			TOKEN_END,
			TOKEN_BOOLEAN,
			TOKEN_COMMAND,
			TOKEN_IDENTIFIER,
			TOKEN_LABEL,
			TOKEN_LITERAL,
			TOKEN_PRAGMA,
			TOKEN_REGISTER,
			TOKEN_SCALAR,
			TOKEN_SYMBOL,
		};

		#define TOKEN_MAX TOKEN_SYMBOL

		static const std::string TOKEN_STR[] = {
			"Begin", "End", "Boolean", "Command", "Identifier", "Label", "Literal",
			"Pragma", "Register", "Scalar", "Symbol",
			};

		#define TOKEN_STRING(_TYPE_) \
			(((_TYPE_) > nescc::core::TOKEN_MAX) ? STRING_UNKNOWN : \
				STRING_CHECK(nescc::core::TOKEN_STR[_TYPE_]))

		class token :
				public nescc::core::unique_id {

			public:

				token(void);

				token(
					__in int type,
					__in_opt int subtype = TOKEN_INVALID,
					__in_opt size_t line = 0
					);

				token(
					__in const token &other
					);

				virtual ~token(void);

				token &operator=(
					__in const token &other
					);

				bool &as_boolean(void);

				std::string &as_literal(void);

				int32_t &as_scalar(void);

				virtual std::string as_string(
					__in_opt bool verbose = false
					) const;

				bool has_subtype(void) const;

				size_t line(void) const;

				void set(
					__in int type,
					__in_opt int subtype = TOKEN_INVALID,
					__in_opt size_t line = 0
					);

				int subtype(void) const;

				virtual std::string to_string(
					__in_opt bool verbose = false
					) const;

				int type(void) const;

			protected:

				bool m_boolean;

				size_t m_line;

				std::string m_literal;

				int32_t m_scalar;

				int m_subtype;

				int m_type;
		};
	}
}

#endif // NESCC_CORE_TOKEN_H_
